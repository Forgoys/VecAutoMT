文件的相对路径：test/tool_diagnostics.log
文件内容：
=== Diagnostic Log ===
Time: 2024-12-06, 19:36:16
==================


--------------------------------------------------------------------------------
Warning

In file: /Users/limutou/work/postG/Project/Autotuning/project/env/dsp_compiler/include/sys/cdefs.h:265:10

Message: '__nonnull' macro redefined

Relevant Code:
263 |    must not be NULL.  */
264 | #if __GNUC_PREREQ (3,3)
265 | # define __nonnull(params) __attribute__ ((__nonnull__ params))
266 | #else
267 | # define __nonnull(params)
    |          ^

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
Note

Message: previous definition is here

Relevant Code:
357 | #define __DECIMAL_DIG__ __LDBL_DECIMAL_DIG__
358 | #define __SSP__ 1
359 | #define __nonnull _Nonnull
360 | #define __null_unspecified _Null_unspecified
361 | #define __nullable _Nullable
    |         ^

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
Fatal Error

In file: /Users/limutou/work/postG/Project/Autotuning/project/env/hthreads/include/hthread_device.h:9:10

Message: 'stdbool.h' file not found

Relevant Code:
7 | #define HTHREAD_DEVICE_H_
8 | 
9 | #include <stdbool.h>
10 | #include <stdarg.h>
11 | #include <stddef.h>
  |          ^

--------------------------------------------------------------------------------

Diagnostic Statistics:
====================
Total Errors  : 1
Total Warnings: 1
====================
-------

文件的相对路径：test/sample.c
文件内容：
#include <stdint.h>

#include "hthread_device.h"
#include <compiler/m3000.h>

#define SEGMENT_SIZE 3840 // (2048 * 8) / 1024 = 16KB

static inline void daxpy_single(uint64_t n, double a, double *x, double *y)
{
    int b = 2;
    for (uint64_t i = 0; i < n; ++i) {
      int tmp = a * x[i];
      y[i + 1] = tmp + b * y[i - 1];
    }
}

__global__ void daxpy_kernel(uint64_t n, double a, double *x, double *y)
{
    int threadId = get_thread_id();
    int threadsNum = get_group_size();
    if (threadId >= threadsNum)
        return;
    uint64_t n_p = n / threadsNum;
    uint64_t extras = n % threadsNum;
    uint64_t offset;
    if (threadId < extras) {
        n_p++;
        offset = threadId * n_p;
    } else {
        offset = threadId * (n_p + 1) - (threadId - extras);
    }

    int len = SEGMENT_SIZE;
    for (int i = 0; i < n_p; i += len) {
        len = (n_p - i) >= SEGMENT_SIZE ? SEGMENT_SIZE : (n_p - i);
        // daxpy_single(len, a, x + offset + i, y + offset + i);
        daxpy_single(len, a, x + offset + i, y + offset + i);
    }
}
-------

文件的相对路径：make.conf
文件内容：
# make.conf

LLVM_PATH = /opt/homebrew/opt/llvm
DEV_PRO_PATH:=/Users/limutou/work/postG/Project/Autotuning/project/env
DEV_CC_ROOT_PATH:=${DEV_PRO_PATH}/dsp_compiler
HTHREADS_ROOT_PATH:=${DEV_PRO_PATH}/hthreads
-------

文件的相对路径：Makefile
文件内容：
# Makefile

include make.conf

# 获取CPU核心数，用于并行编译
NPROCS = $(shell nproc || sysctl -n hw.ncpu || echo 2)
MAKEFLAGS += -j$(NPROCS)

HTHREADS_INCLUDE_PATH:=${HTHREADS_ROOT_PATH}/include
DEV_CC_INCLUDE_PATH:=${DEV_CC_ROOT_PATH}/include

DEV_INCLUDE_PATH:=${DEV_CC_INCLUDE_PATH} ${HTHREADS_INCLUDE_PATH}
DEV_INCLUDE_FLAGS:=$(foreach i, ${DEV_INCLUDE_PATH}, -I${i})

# 设置本地 LLVM 和 Clang 的路径
LLVM_HOME := /opt/homebrew/opt/llvm

# 使用本地的 clang++
CLANG := $(LLVM_HOME)/bin/clang++
CLANG_FLAGS := -std=c++14 -fno-color-diagnostics -fno-rtti

# 使用本地的 llvm-config
LLVM_CONFIG := $(LLVM_HOME)/bin/llvm-config
LLVM_CXXFLAGS := $(shell $(LLVM_CONFIG) --cxxflags)
LLVM_LDFLAGS := $(shell $(LLVM_CONFIG) --link-shared --ldflags)
LLVM_LIBS := $(shell $(LLVM_CONFIG) --link-shared --libs)
LLVM_SYSTEM_LIBS := $(shell $(LLVM_CONFIG) --system-libs)
LLVM_INCLUDEDIR := $(shell $(LLVM_CONFIG) --includedir)

# Clang 的包含目录
CLANG_INCLUDEDIR := $(LLVM_HOME)/include

# 使用 libclang-cpp 库
CLANG_LIBS := -lclang-cpp

# 合并所有选项
TOOL_CLANG_FLAGS := $(CLANG_FLAGS) $(LLVM_CXXFLAGS) -I$(CLANG_INCLUDEDIR) -Iinclude
TOOL_LINK_FLAGS := -L$(LLVM_HOME)/lib -Wl,-rpath,$(LLVM_HOME)/lib $(LLVM_LDFLAGS) $(LLVM_LIBS) $(CLANG_LIBS) $(LLVM_SYSTEM_LIBS)

# 在运行时指定资源目录
ARGS := -resource-dir=$(LLVM_HOME)/lib/clang/18

# 源文件和目标文件
SRC_DIR := src
SRCS := $(wildcard $(SRC_DIR)/*.cpp)
OBJS := $(SRCS:%.cpp=%.o)

# 输入输出文件路径
TEST_DIR := test
SRC_FILE := $(TEST_DIR)/sample.c
LOCATE_OUTPUT := $(TEST_DIR)/locate_output.json
RESTORE_OUTPUT := $(TEST_DIR)/restore_output.json
MODIFY_OUTPUT := $(TEST_DIR)/modified.c

# Run mode and arguments
.PHONY: all build run run-locate run-restore run-modify clean

all: build

build: bin/VecAutoMT

bin/VecAutoMT: $(OBJS)
	@mkdir -p bin
	$(CLANG) $(TOOL_CLANG_FLAGS) -o $@ $^ $(TOOL_LINK_FLAGS)

$(SRC_DIR)/%.o: $(SRC_DIR)/%.cpp
	@mkdir -p $(dir $@)
	$(CLANG) $(TOOL_CLANG_FLAGS) -c $< -o $@

# 将run目标分解为具体的运行模式
run-locate: build
	@mkdir -p $(TEST_DIR)
	export LD_LIBRARY_PATH=$(LLVM_HOME)/lib:$$LD_LIBRARY_PATH; \
	bin/VecAutoMT -locate $(SRC_FILE) -output $(LOCATE_OUTPUT) -- $(DEV_INCLUDE_FLAGS) $(ARGS)

run-restore: build
	@mkdir -p $(TEST_DIR)
	export LD_LIBRARY_PATH=$(LLVM_HOME)/lib:$$LD_LIBRARY_PATH; \
	bin/VecAutoMT -restore $(SRC_FILE) -input $(LOCATE_OUTPUT) -output $(RESTORE_OUTPUT) -- $(DEV_INCLUDE_FLAGS) $(ARGS)

run-modify: build
	@mkdir -p $(TEST_DIR)
	export LD_LIBRARY_PATH=$(LLVM_HOME)/lib:$$LD_LIBRARY_PATH; \
	bin/VecAutoMT -modify $(SRC_FILE) -input $(RESTORE_OUTPUT) -output $(MODIFY_OUTPUT) -- $(DEV_INCLUDE_FLAGS) $(ARGS)

# 使用run目标来调用具体的运行模式
run:
	@if [ "$(filter locate,$(MAKECMDGOALS))" ]; then \
		$(MAKE) run-locate; \
	elif [ "$(filter restore,$(MAKECMDGOALS))" ]; then \
		$(MAKE) run-restore; \
	elif [ "$(filter modify,$(MAKECMDGOALS))" ]; then \
		$(MAKE) run-modify; \
	else \
		echo "Please specify a mode: make run locate|restore|modify"; \
		exit 1; \
	fi

# Additional targets to allow 'make run MODE'
locate restore modify:
	@:

clean:
	rm -rf bin
	rm -f $(OBJS)
	rm -f $(LOCATE_OUTPUT) $(RESTORE_OUTPUT) $(MODIFY_OUTPUT)-------

文件的相对路径：include/preprocessor_config.h
文件内容：
#ifndef PREPROCESSOR_CONFIG_H
#define PREPROCESSOR_CONFIG_H

#include "util.h"
#include "clang/Basic/Diagnostic.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Frontend/FrontendActions.h"
#include "clang/Rewrite/Core/Rewriter.h"
#include "clang/Tooling/Tooling.h"

// 预处理器配置类
class PreprocessorConfig {
public:
    static void configure(clang::CompilerInstance &CI);
};

#endif // PREPROCESSOR_CONFIG_H-------

文件的相对路径：include/frontend_action.h
文件内容：
#ifndef FRONTEND_ACTION_H
#define FRONTEND_ACTION_H

#include "util.h"
#include "clang/Frontend/FrontendActions.h"
#include "clang/Tooling/Tooling.h"
#include "clang/Rewrite/Core/Rewriter.h"
#include "command_line_options.h"
#include "json_manager.h"
#include "diagnostic_tool.h"

// 外部声明的重写器
extern clang::Rewriter TheRewriter;

// 自定义前端Action类
class MyFrontendAction : public clang::ASTFrontendAction
{
protected:
    std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(
        clang::CompilerInstance &CI,
        llvm::StringRef InFile) override;

    bool BeginSourceFileAction(clang::CompilerInstance &CI) override;
};

class MyASTConsumer : public clang::ASTConsumer
{
private:
    clang::ast_matchers::MatchFinder matchFinder;

public:
    MyASTConsumer();

    void HandleTranslationUnit(clang::ASTContext &Context) override;
};

// 创建自定义前端Action工厂的辅助函数
std::unique_ptr<clang::tooling::FrontendActionFactory> createCustomFrontendActionFactory(
    std::shared_ptr<MyDiagnosticConsumer> DiagConsumer);

#endif
-------

文件的相对路径：include/json_manager.h
文件内容：
#ifndef JSON_MANAGER_H
#define JSON_MANAGER_H

#include "array_matcher.h"
#include "command_line_options.h"
#include "util.h"
#include <string>
#include <fstream>
#include <stdexcept>

class JsonManager {
public:
    static JsonManager& instance();

    void readInputJson(const std::string& filename);
    void writeOutputJson(const std::string& filename);

    json& getInputJson();
    json& getOutputJson();

    void clearOutputJson();
    void addArrayAccess(const ArrayAccessInfo& info);

private:
    JsonManager() = default;

    json inputJson = json::array();
    json outputJson = json::array();

    void validateInputJson() const;
    // 处理locate模式
    void handleLocateMode(const ArrayAccessInfo& info);

    // 处理restore模式
    void handleRestoreMode(const ArrayAccessInfo& info);

    // 处理modify模式
    void handleModifyMode(const ArrayAccessInfo& info) {};
};

#endif // JSON_MANAGER_H-------

文件的相对路径：include/command_line_options.h
文件内容：
#ifndef COMMAND_LINE_OPTIONS_H
#define COMMAND_LINE_OPTIONS_H

#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"
#include "llvm/Support/CommandLine.h"
#include <string>

class CommandLineOptions
{
public:
    static CommandLineOptions &instance();

    bool getLocateMode() const;
    bool getRestoreMode() const;
    bool getModifyMode() const;
    bool getDiagnosticLogToFile() const;
    std::string getDiagnosticLogFile() const;
    std::string getInputFile() const;
    std::string getOutputFile() const;

    void initialize(int argc, const char **argv);
    clang::tooling::CommonOptionsParser &getOptionsParser();
    const clang::tooling::CommonOptionsParser &getOptionsParser() const;
    [[nodiscard]] std::string toString() const;

private:
    CommandLineOptions() = default;
    static void registerOptions();

    static llvm::cl::OptionCategory ToolCategory;
    static llvm::cl::opt<bool> LocateMode;
    static llvm::cl::opt<bool> RestoreMode;
    static llvm::cl::opt<bool> ModifyMode;
    static llvm::cl::opt<bool> DiagnosticLogToFile;
    static llvm::cl::opt<std::string> DiagnosticLogFile;
    static llvm::cl::opt<std::string> InputFile;
    static llvm::cl::opt<std::string> OutputFile;

    std::unique_ptr<clang::tooling::CommonOptionsParser> OptionsParser;
};

#endif // COMMAND_LINE_OPTIONS_H-------

文件的相对路径：include/util.h
文件内容：
#ifndef UTIL_H
#define UTIL_H

#include "nlohmann/json.hpp"
#include "nlohmann/fifo_map.hpp"
#include "clang/AST/AST.h"
#include "clang/ASTMatchers/ASTMatchFinder.h"
#include "clang/ASTMatchers/ASTMatchers.h"
#include "clang/Basic/SourceManager.h"
#include "clang/Frontend/FrontendActions.h"
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"
#include "llvm/Support/CommandLine.h"

#include <functional>
#include <memory>
#include <optional>
#include <stdexcept>
#include <string>
#include <system_error>
#include <vector>

// 首先定义使用 fifo_map 的 json 类型
template<class K, class V, class dummy_compare, class A>
using fifo_map_type = nlohmann::fifo_map<K, V, nlohmann::fifo_map_compare<K>, A>;

// 然后定义使用 fifo_map 的 json
using json = nlohmann::basic_json<fifo_map_type>;

// 工具运行模式
enum class ToolMode
{
    LOCATE, // 定位模式
    RESTORE, // 恢复模式
    MODIFY // 修改模式
};

// 位置信息结构
struct LocationInfo
{
    std::string filename;
    std::string functionName;
    unsigned startLine;
    unsigned endLine;
    std::string sourceText;

    // 转换为JSON
    json toJson() const;

    // 从JSON构造
    static LocationInfo fromJson(const json &j);

    // 打印结构信息
    [[nodiscard]] std::string toString() const {
        return "LocationInfo {\n"
               "  filename: '" + filename + "',\n"
               "  functionName: '" + functionName + "',\n"
               "  startLine: " + std::to_string(startLine) + ",\n"
               "  endLine: " + std::to_string(endLine) + ",\n"
               "  sourceText: '" + sourceText + "'\n"
               "}";
    }
};

// 工具配置
struct ToolConfig
{
    ToolMode mode;
    std::string inputFile;
    std::string outputFile;
    bool verbose;

    static ToolConfig parseCommandLine(int argc, const char **argv);
};

#endif // UTIL_H
-------

文件的相对路径：include/code_modifier.h
文件内容：
#ifndef CODE_MODIFIER_H
#define CODE_MODIFIER_H

#include "util.h"
#include "clang/Rewrite/Core/Rewriter.h"

using namespace clang;
using namespace clang::ast_matchers;

// 代码修改器 - 基础版本
class CodeModifier : public clang::ast_matchers::MatchFinder::MatchCallback
{
public:
    CodeModifier(clang::Rewriter &rewriter) : rewrite(rewriter) {}
    virtual void run(const clang::ast_matchers::MatchFinder::MatchResult &Result) override;

protected:
    clang::Rewriter &rewrite;
};

// 代码修改器 - 扩展版本
class ExtendedCodeModifier : public CodeModifier
{
public:
    ExtendedCodeModifier(clang::Rewriter &rewriter) : CodeModifier(rewriter) {}

    // 添加边界检查
    void addBoundsCheck(const clang::ArraySubscriptExpr *Array, const clang::ForStmt *Loop);
    // 添加优化提示
    void addOptimizationHint(const clang::ArraySubscriptExpr *Array);
    // 添加并行化提示
    void addParallelizationHint(const clang::ForStmt *Loop);
};

#endif // CODE_MODIFIER_H-------

文件的相对路径：include/diagnostic_tool.h
文件内容：
#ifndef DIAGNOSTIC_TOOL_H
#define DIAGNOSTIC_TOOL_H

#include <clang/Basic/Diagnostic.h>
#include <clang/Basic/DiagnosticOptions.h>
#include <clang/Basic/DiagnosticIDs.h>
#include <clang/Frontend/TextDiagnosticPrinter.h>
#include <llvm/Support/MemoryBuffer.h>
#include <llvm/Support/raw_ostream.h>
#include <string>
#include <vector>
#include <memory>
#include <utility>

// ANSI Color codes
struct Colors
{
    static constexpr const char *RESET = "\033[0m";
    static constexpr const char *RED = "\033[31m";
    static constexpr const char *GREEN = "\033[32m";
    static constexpr const char *YELLOW = "\033[33m";
    static constexpr const char *BLUE = "\033[34m";
    static constexpr const char *MAGENTA = "\033[35m";
    static constexpr const char *CYAN = "\033[36m";
    static constexpr const char *BOLD = "\033[1m";
    static constexpr const char *DIM = "\033[2m";
};

class MyDiagnosticConsumer : public clang::DiagnosticConsumer
{
public:
    // 错误信息的结构体
    struct DiagnosticInfo
    {
        std::string Message; // 错误信息
        std::string Filename; // 文件名
        unsigned Line; // 行号
        unsigned Column; // 列号
        std::string Severity; // 严重程度
        std::string Category; // 错误类别
        std::string CodeSnippet; // 相关代码片段
        std::string CaretLine; // 错误位置标记行
        std::vector<std::string> Notes; // 相关的注释信息
        clang::DiagnosticsEngine::Level Level; // 保存原始级别用于着色
    };

    MyDiagnosticConsumer(bool logToFile = false,
                         const std::string &logFilename = "clang_diagnostics.log");

    void HandleDiagnostic(clang::DiagnosticsEngine::Level DiagLevel,
                          const clang::Diagnostic &Info) override;

    // 完成所有诊断后的最终输出
    void Finish();

    // 获取统计信息
    void PrintStatistics();

    // 清除所有诊断信息
    void Clear();

    // 获取所有诊断信息
    const std::vector<DiagnosticInfo> &GetDiagnostics() const;

private:
    bool LogToFile;
    std::string LogFilename;
    std::shared_ptr<clang::DiagnosticOptions> DiagOpts;
    std::vector<DiagnosticInfo> Diagnostics;
    unsigned ErrorCount;
    unsigned WarningCount;

    // 获取源代码片段和错误标记
    std::pair<std::string, std::string> GetSourceSnippetAndCaret(
        const clang::FullSourceLoc &Loc,
        const clang::Diagnostic &Info,
        unsigned Context);

    // 格式化诊断信息
    std::string FormatDiagnostic(const DiagnosticInfo &Info) const;

    // 输出诊断信息
    // void OutputDiagnostic(const DiagnosticInfo &Info);

    // 辅助函数：获取行内容
    std::string GetLineContent(const clang::SourceManager &SM,
                               clang::SourceLocation Loc) const;

    // 获取诊断级别对应的颜色
    const char *GetSeverityColor(clang::DiagnosticsEngine::Level Level) const;

    // 根据是否输出到文件返回相应的颜色字符串
    std::string Color(const char *ColorCode) const;

    // 输出所有缓存的诊断信息
    // void OutputAllDiagnostics() const;
};

#endif // DIAGNOSTIC_TOOL_H
-------

文件的相对路径：include/array_matcher.h
文件内容：
#ifndef ARRAY_MATCHER_H
#define ARRAY_MATCHER_H

#include <clang/AST/RecursiveASTVisitor.h>

#include "util.h"
using namespace clang;
using namespace clang::ast_matchers;
using namespace clang::tooling;

// 数组操作类型
enum class ArrayOpType
{
    READ, // 读取操作
    WRITE, // 写入操作
    READ_WRITE // 读写操作
};

// 扩展的数组计算信息
struct ArrayComputeInfo
{
    std::string expression; // 计算表达式
    ArrayOpType opType; // 操作类型
    LocationInfo location; // 位置信息
    std::vector<std::string> dependentVars; // 依赖的其他变量
    [[nodiscard]] std::string toString() const
    {
        std::string opTypeStr;
        switch (opType) {
            case ArrayOpType::READ:
                opTypeStr = "READ";
                break;
            case ArrayOpType::WRITE:
                opTypeStr = "WRITE";
                break;
            case ArrayOpType::READ_WRITE:
                opTypeStr = "READ_WRITE";
                break;
        }

        std::string deps = "[";
        for (const auto &var: dependentVars) {
            if (deps.length() > 1) {
                deps += ", ";
            }
            deps += var;
        }
        deps += "]";

        return "ArrayComputeInfo {\n"
               "  expression: '" + expression + "',\n"
               "  opType: " + opTypeStr + ",\n"
               "  location: " + location.toString() + ",\n"
               "  dependentVars: " + deps + "\n"
               "}";
    }
};

// 扩展的数组访问信息
struct ArrayAccessInfo
{
    std::string arrayName;
    LocationInfo arrayLocation;
    LocationInfo forLoopLocation;
    std::string indexVarName;
    std::vector<ArrayComputeInfo> computeInfos; // 所有相关的计算

    // 循环信息
    struct
    {
        int64_t start;
        int64_t end;
        int64_t step;
        bool isConstBound;

        [[nodiscard]] std::string toString() const
        {
            return "LoopInfo { "
                   + std::string("start: ") + std::to_string(start) + ", "
                   + std::string("end: ") + std::to_string(end) + ", "
                   + std::string("step: ") + std::to_string(step) + ", "
                   + std::string("isConstBound: ") + (isConstBound ? "true" : "false") + " }";
        }
    } loopInfo;

    json toJson() const;

    static ArrayAccessInfo fromJson(const json &j);

    [[nodiscard]] std::string toString() const
    {
        std::string computeInfoStr = "[\n";
        for (const auto &computeInfo: computeInfos) {
            computeInfoStr += "    " + computeInfo.toString() + ",\n";
        }
        computeInfoStr += "  ]";

        return "ArrayAccessInfo {\n"
               "  arrayName: '" + arrayName + "',\n"
               "  arrayLocation: " + arrayLocation.toString() + ",\n"
               "  forLoopLocation: " + forLoopLocation.toString() + ",\n"
               "  indexVarName: '" + indexVarName + "',\n"
               "  computeInfos: " + computeInfoStr + ",\n"
               "  loopInfo: " + loopInfo.toString() + "\n"
               "}" + "\n";
    }
};

class ArrayMatcher : public MatchFinder::MatchCallback
{
public:
    ArrayMatcher(json &output) : outputJson(output)
    {
    }

    virtual void run(const MatchFinder::MatchResult &Result) override;

protected:
    json &outputJson;

    // 计算访问器 - 用于收集数组计算信息
    class ComputeVisitor : public RecursiveASTVisitor<ComputeVisitor>
    {
    public:
        ComputeVisitor(const std::string &arrayName,
                       SourceManager &SM,
                       const LangOptions &langOpts,
                       const std::string &funcName);

        bool VisitBinaryOperator(BinaryOperator *op);

        std::vector<ArrayComputeInfo> computeInfos;

    private:
        std::string arrayName;
        SourceManager &SM;
        const LangOptions &langOpts;
        std::string funcName;

        bool containsArray(const Expr *expr, const std::string &arrayName) const;

        ArrayOpType determineOpType(BinaryOperator *op) const;

        LocationInfo getLocation(BinaryOperator *op) const;

        void collectDependenciesImpl(const Expr *expr, std::vector<std::string> &deps) const;

        std::vector<std::string> collectDependencies(const Expr *expr) const;
    };

    // 处理locate模式
    void handleLocateMode(const MatchFinder::MatchResult &Result);

    // 处理restore模式
    void handleRestoreMode(const MatchFinder::MatchResult &Result);

    // 处理modify模式
    void handleModifyMode(const MatchFinder::MatchResult &Result)
    {
    };

    // 验证循环结构
    bool isValidLoop(const ForStmt *Loop) const;

    static std::string getSourceText(const Stmt *stmt, SourceManager &SM, const LangOptions &langOpts);

    std::string getCurrentFunctionName(const MatchFinder::MatchResult &Result);

    void collectArrayComputeInfo(const ArraySubscriptExpr *Array,
                                 const ForStmt *Loop,
                                 ArrayAccessInfo &Info,
                                 const MatchFinder::MatchResult &Result);

    // 分析数组操作类型
    ArrayOpType analyzeArrayOpType(const ArraySubscriptExpr *Array) const;

    // 获取循环信息
    bool getLoopInfo(const ForStmt *Loop, ArrayAccessInfo &Info) const;

private:
    // 新增：分析循环变量初始化
    bool analyzeLoopInit(const ForStmt *Loop, ArrayAccessInfo &Info);

    // 新增：分析循环条件
    bool analyzeLoopCondition(const ForStmt *Loop, ArrayAccessInfo &Info);

    // 新增：分析循环步进
    bool analyzeLoopIncrement(const ForStmt *Loop, ArrayAccessInfo &Info);

    // 新增：收集数组相关计算信息
    void collectArrayComputations(const Stmt *stmt,
                                  const std::string &arrayName,
                                  std::vector<ArrayComputeInfo> &computeInfos,
                                  SourceManager &SM,
                                  const LangOptions &langOpts,
                                  const std::string &funcName);
};

#endif // ARRAY_MATCHER_H
-------

文件的相对路径：print_files.sh
文件内容：
#!/bin/bash

# 输出文件名
output_file="all_files_content.txt"

# 清空或创建输出文件
> "$output_file"

# 递归查找所有文件并处理，忽略 .git 和 .vscode 目录
find . -type f ! -path "*.git/*"  ! -path "./include/testHandler.*" ! -path "*.idea/*" ! -path "print_files.sh" ! -path "README.md" ! -path "*doc/*" ! -path "*.vscode/*" ! -name "$output_file" -print0 | while IFS= read -r -d '' file; do
    # 跳过二进制文件和特殊文件
    if file "$file" | grep -q "text"; then
        # 写入文件路径
        echo "文件的相对路径：${file:2}" >> "$output_file"
        echo "文件内容：" >> "$output_file"
        # 写入文件内容
        cat "$file" >> "$output_file"
        # 写入分隔符
        echo "-------" >> "$output_file"
        echo "" >> "$output_file"
    fi
done

echo "处理完成，结果保存在 $output_file"-------

文件的相对路径：README.md
文件内容：
# VecAutoMT - Auto Vectorization Tool for MT-3000

VecAutoMT 是一个基于 LLVM/Clang 的代码分析工具，用于分析和处理 C/C++ 代码中的数组访问模式。该工具主要用于识别和处理可能适合向量化优化的代码片段。

## 功能特性

该工具提供三种主要工作模式：

1. **定位模式 (Locate)**
   - 识别代码中的数组访问模式
   - 分析 for 循环中的数组索引使用
   - 输出详细的位置信息（文件、函数、行号）
   - 生成结构化的 JSON 分析报告

2. **恢复模式 (Restore)**
   - 基于之前生成的 JSON 分析报告
   - 重新定位代码中的关键位置
   - 支持代码修改后的重新分析

3. **修改模式 (Modify)**
   - 自动添加代码优化提示
   - 插入边界检查
   - 添加向量化和并行化建议

## 前置要求

- LLVM/Clang (推荐使用 14.0.0 或更高版本)
- C++14 或更高版本的编译器
- Make 构建工具

## 安装

1. 克隆仓库：
```bash
git clone https://github.com/Forgoys/VecAutoMT
cd VecAutoMT
```

2. 配置环境：
编辑 `make.conf` 文件，设置 LLVM 安装路径：
```makefile
LLVM_PATH = /path/to/your/llvm
```

3. 编译工具：
```bash
make
```

## 使用方法

### 基本用法

```bash
./bin/VecAutoMT [options] <source-file> -- [compiler-options]
```

### 命令行选项

- `-locate`: 启用定位模式
- `-restore`: 启用恢复模式
- `-modify`: 启用修改模式
- `-output <file>`: 指定输出文件
- `-input <file>`: 指定输入 JSON 文件（恢复模式需要）

### 使用示例

1. 定位模式分析：
```bash
./bin/VecAutoMT -locate -output analysis.json test.c -- -I/path/to/includes
```

2. 基于分析结果恢复：
```bash
./bin/VecAutoMT -restore -input analysis.json test.c -- -I/path/to/includes
```

3. 添加优化提示：
```bash
./bin/VecAutoMT -modify -output modified.c test.c -- -I/path/to/includes
```

## 输出格式

### JSON 输出格式（定位模式）

```json
[
  {
    "filename": "test.c",
    "function": "example_function",
    "forLoop": {
      "startLine": 10,
      "endLine": 15,
      "sourceText": "for(int i = 0; i < n; i++)"
    },
    "arrays": [
      {
        "name": "array",
        "indexVar": "i",
        "line": 12,
        "sourceText": "array[i] = value"
      }
    ]
  }
]
```

## 支持的分析模式

工具当前支持以下分析模式：

1. 数组访问模式：
   - 简单的循环索引访问
   - 带步长的数组访问
   - 多维数组访问

2. 循环特征：
   - 单变量自增循环
   - 边界检查识别
   - 循环步长分析

## 限制和注意事项

- 目前仅支持 C/C++ 源代码分析
- 分析结果依赖于代码的具体形式
- 某些复杂的数组访问模式可能无法被正确识别
- 修改模式下的代码变更需要人工审查
-------

文件的相对路径：.gitignore
文件内容：
# 忽略 macOS 系统自动生成的 .DS_Store 文件
.DS_Store

# 忽略 VSCode 的设置文件夹 .vscode
.vscode/

.idea/

*.o

all_files_content.txt
print_files.sh-------

文件的相对路径：src/frontend_action.cpp
文件内容：
# include "frontend_action.h"
#include "preprocessor_config.h"
#include "array_matcher.h"
#include "code_modifier.h"
#include <iostream>

std::unique_ptr<clang::ASTConsumer> MyFrontendAction::CreateASTConsumer(
    clang::CompilerInstance &CI,
    llvm::StringRef InFile)
{
    return std::make_unique<MyASTConsumer>();
}

bool MyFrontendAction::BeginSourceFileAction(clang::CompilerInstance &CI)
{
    auto &options = CommandLineOptions::instance();

    // 设置诊断选项
    if (CI.hasDiagnostics()) {
        auto &diagEngine = CI.getDiagnostics();
        diagEngine.setShowColors(!options.getDiagnosticLogToFile());
        // 注意：其他诊断选项已在DiagnosticConsumer中设置
    }

    if (!options.getModifyMode()) {
        PreprocessorConfig::configure(CI);
        std::cout << "Preprocessor configuration completed.\n";
    } else {
        TheRewriter.setSourceMgr(CI.getSourceManager(), CI.getLangOpts());
    }
    return true;
}

MyASTConsumer::MyASTConsumer()
{
    auto &options = CommandLineOptions::instance();
    auto &jsonManager = JsonManager::instance();

    if (options.getLocateMode()) {
        jsonManager.clearOutputJson();

        auto matcher = forStmt(
            hasLoopInit(declStmt(hasSingleDecl(varDecl().bind("loopVar")))),
            forEachDescendant(arraySubscriptExpr().bind("arrayAccess")),
            hasAncestor(functionDecl().bind("containingFunction"))
        ).bind("forLoop");

        matchFinder.addMatcher(matcher, new ArrayMatcher(jsonManager.getOutputJson()));
        std::cout << "Array matcher added successfully.\n";
    } else if (options.getRestoreMode()) {
        auto &inputJson = jsonManager.getInputJson();

        for (const auto &item: inputJson) {
            try {
                if (!item.contains("functions")) {
                    std::cerr << "Warning: Input JSON item missing 'functions' field\n";
                    continue;
                }

                for (const auto &func: item["functions"]) {
                    if (!func.contains("name") || !func.contains("forLoops")) {
                        std::cerr << "Warning: Function object missing required fields\n";
                        continue;
                    }

                    std::string funcName = func["name"].get<std::string>();

                    for (const auto &forloop: func["forLoops"]) {
                        if (!forloop.contains("arrays") || !forloop.contains("startLine")) {
                            std::cerr << "Warning: ForLoop missing required fields\n";
                            continue;
                        }

                        int startLine = forloop["startLine"].get<int>();

                        for (const auto &array: forloop["arrays"]) {
                            if (!array.contains("name") || !array.contains("indexVar") || !array.contains("line")) {
                                std::cerr << "Warning: Array object missing required fields\n";
                                continue;
                            }

                            std::string arrayName = array["name"].get<std::string>();
                            std::string indexVar = array["indexVar"].get<std::string>();
                            int arrayLine = array["line"].get<int>();

                            // 构建更精确的matcher
                            auto matcher = arraySubscriptExpr(
                                // 确保在指定函数内
                                hasAncestor(functionDecl(hasName(funcName)).bind("functionDecl")),
                                // 确保基础表达式是正确的数组
                                hasLHS(implicitCastExpr(has(declRefExpr(to(varDecl(hasName(arrayName))))))),
                                // 确保索引变量匹配
                                hasRHS(implicitCastExpr(has(declRefExpr(to(varDecl(hasName(indexVar))))))),
                                // 确保在for循环内
                                hasAncestor(forStmt().bind("forLoop"))
                            ).bind("arrayAccess");

                            // 将array信息传递给matcher处理器
                            matchFinder.addMatcher(matcher, new ArrayMatcher(jsonManager.getOutputJson()));
                        }
                    }
                }
            } catch (const json::exception &e) {
                std::cerr << "Warning: Error processing JSON item: " << e.what() << "\n";
                continue;
            }
        }
    } else if (options.getModifyMode()) {
        auto matcher = arraySubscriptExpr(
            hasAncestor(forStmt().bind("forLoop"))
        ).bind("arrayAccess");
        matchFinder.addMatcher(matcher, new ExtendedCodeModifier(TheRewriter));
    }
}

void MyASTConsumer::HandleTranslationUnit(clang::ASTContext &Context)
{
    matchFinder.matchAST(Context);

    auto &options = CommandLineOptions::instance();
    if (options.getLocateMode() && !options.getOutputFile().empty()) {
        try {
            JsonManager::instance().writeOutputJson(options.getOutputFile());
            std::cout << "JSON output written to: " << options.getOutputFile() << "\n";
        } catch (const std::exception &e) {
            std::cerr << "Error writing JSON output: " << e.what() << "\n";
        }
    }
}

// 自定义 FrontendAction 类
class CustomFrontendAction : public MyFrontendAction {
public:
    explicit CustomFrontendAction(std::shared_ptr<MyDiagnosticConsumer> consumer)
        : DiagConsumer(std::move(consumer)) {}

    bool BeginSourceFileAction(clang::CompilerInstance &CI) override {
        if (CI.hasDiagnostics() && DiagConsumer) {
            CI.getDiagnostics().setClient(DiagConsumer.get());
        }
        return MyFrontendAction::BeginSourceFileAction(CI);
    }

private:
    std::shared_ptr<MyDiagnosticConsumer> DiagConsumer;
};

// 自定义 FrontendActionFactory 类
class CustomFrontendActionFactory : public clang::tooling::FrontendActionFactory {
public:
    explicit CustomFrontendActionFactory(std::shared_ptr<MyDiagnosticConsumer> consumer)
        : DiagConsumer(std::move(consumer)) {}

    std::unique_ptr<clang::FrontendAction> create() override {
        return std::make_unique<CustomFrontendAction>(DiagConsumer);
    }

private:
    std::shared_ptr<MyDiagnosticConsumer> DiagConsumer;
};

// 工厂函数的实现
std::unique_ptr<clang::tooling::FrontendActionFactory> createCustomFrontendActionFactory(
    std::shared_ptr<MyDiagnosticConsumer> DiagConsumer)
{
    return std::make_unique<CustomFrontendActionFactory>(std::move(DiagConsumer));
}-------

文件的相对路径：src/array_matcher.cpp
文件内容：
#include "array_matcher.h"

#include <command_line_options.h>

#include "json_manager.h"
#include "clang/AST/RecursiveASTVisitor.h"

void ArrayMatcher::run(const MatchFinder::MatchResult &Result)
{
    const auto &options = CommandLineOptions::instance();
    if (options.getLocateMode()) {
        handleLocateMode(Result);
    } else if (options.getRestoreMode()) {
        handleRestoreMode(Result);
    } else {
        handleModifyMode(Result);
    }
}

void ArrayMatcher::handleLocateMode(const MatchFinder::MatchResult &Result)
{
    const auto *arrayExpr = Result.Nodes.getNodeAs<ArraySubscriptExpr>("arrayAccess");
    const auto *forStmt = Result.Nodes.getNodeAs<ForStmt>("forLoop");
    const auto *func = Result.Nodes.getNodeAs<FunctionDecl>("containingFunction");

    if (!arrayExpr || !forStmt || !func || !isValidLoop(forStmt))
        return;

    // 创建基础信息
    ArrayAccessInfo info;

    // 获取源码管理器
    SourceManager &SM = *Result.SourceManager;
    const LangOptions &langOpts = Result.Context->getLangOpts();

    // 获取数组名称
    const Expr *base = arrayExpr->getBase()->IgnoreParenImpCasts();
    if (const auto *declRef = dyn_cast<DeclRefExpr>(base)) {
        info.arrayName = declRef->getDecl()->getNameAsString();
    }

    // 获取循环变量名
    if (const auto *init = dyn_cast<DeclStmt>(forStmt->getInit())) {
        if (const auto *varDecl = dyn_cast<VarDecl>(init->getSingleDecl())) {
            info.indexVarName = varDecl->getNameAsString();
        }
    }

    // 填充位置信息的辅助函数
    auto fillLocationInfo = [&SM, &langOpts](const Stmt *stmt, const std::string &funcName) -> LocationInfo {
        SourceLocation start = stmt->getBeginLoc();
        SourceLocation end = stmt->getEndLoc();

        LocationInfo loc;
        loc.filename = SM.getFilename(start).str();
        loc.functionName = funcName;
        loc.startLine = SM.getSpellingLineNumber(start);
        loc.endLine = SM.getSpellingLineNumber(end);
        loc.sourceText = Lexer::getSourceText(
            CharSourceRange::getCharRange(start, Lexer::getLocForEndOfToken(end, 0, SM, langOpts)),
            SM,
            langOpts
        ).str();

        return loc;
    };

    // 获取位置信息
    info.arrayLocation = fillLocationInfo(arrayExpr, func->getNameAsString());
    info.forLoopLocation = fillLocationInfo(forStmt, func->getNameAsString());

    // 获取循环信息
    // if (!getLoopInfo(forStmt, info)) {
    //     return;
    // }

    // 收集所有相关计算
    // collectArrayComputeInfo(arrayExpr, forStmt, info, Result);
    // llvm::outs() << info.toString();
    // 添加到输出JSON
    JsonManager::instance().addArrayAccess(info);
}

void ArrayMatcher::handleRestoreMode(const MatchFinder::MatchResult &Result)
{
    const auto *arrayExpr = Result.Nodes.getNodeAs<ArraySubscriptExpr>("arrayAccess");
    const auto *forStmt = Result.Nodes.getNodeAs<ForStmt>("forLoop");

    if (!arrayExpr || !forStmt || !isValidLoop(forStmt)) {
        return;
    }

    // 创建数组访问信息结构
    ArrayAccessInfo info;
    SourceManager &SM = *Result.SourceManager;
    const LangOptions &langOpts = Result.Context->getLangOpts();

    // 获取数组名称
    const Expr *base = arrayExpr->getBase()->IgnoreParenImpCasts();
    if (const auto *declRef = dyn_cast<DeclRefExpr>(base)) {
        info.arrayName = declRef->getDecl()->getNameAsString();
    }

    // 获取循环变量名称
    if (const auto *init = dyn_cast<DeclStmt>(forStmt->getInit())) {
        if (const auto *varDecl = dyn_cast<VarDecl>(init->getSingleDecl())) {
            info.indexVarName = varDecl->getNameAsString();
        }
    }

    // 收集位置信息
    info.arrayLocation = {
        SM.getFilename(arrayExpr->getBeginLoc()).str(),
        getCurrentFunctionName(Result),
        SM.getSpellingLineNumber(arrayExpr->getBeginLoc()),
        SM.getSpellingLineNumber(arrayExpr->getEndLoc()),
        getSourceText(arrayExpr, SM, langOpts)
    };

    info.forLoopLocation = {
        SM.getFilename(forStmt->getBeginLoc()).str(),
        getCurrentFunctionName(Result),
        SM.getSpellingLineNumber(forStmt->getBeginLoc()),
        SM.getSpellingLineNumber(forStmt->getEndLoc()),
        getSourceText(forStmt, SM, langOpts)
    };

    // 分析循环信息
    analyzeLoopInit(forStmt, info);
    analyzeLoopCondition(forStmt, info);
    analyzeLoopIncrement(forStmt, info);

    // 收集所有相关的数组计算
    collectArrayComputations(forStmt->getBody(),
                             info.arrayName,
                             info.computeInfos,
                             SM,
                             langOpts,
                             info.arrayLocation.functionName);

    // 输出调试信息
    // llvm::outs() << info.toString();

    // 将信息添加到输出JSON
    JsonManager::instance().addArrayAccess(info);
}

bool ArrayMatcher::analyzeLoopInit(const ForStmt *Loop, ArrayAccessInfo &Info)
{
    if (const auto *init = dyn_cast<DeclStmt>(Loop->getInit())) {
        if (const auto *varDecl = dyn_cast<VarDecl>(init->getSingleDecl())) {
            if (const auto *initExpr = varDecl->getInit()) {
                if (const auto *literal = dyn_cast<IntegerLiteral>(initExpr)) {
                    Info.loopInfo.start = literal->getValue().getSExtValue();
                    return true;
                }
            }
        }
    }
    Info.loopInfo.start = 0; // 默认值
    return false;
}

bool ArrayMatcher::analyzeLoopCondition(const ForStmt *Loop, ArrayAccessInfo &Info)
{
    if (const auto *cond = dyn_cast<BinaryOperator>(Loop->getCond())) {
        if (const auto *rhs = dyn_cast<IntegerLiteral>(cond->getRHS()->IgnoreParenImpCasts())) {
            Info.loopInfo.end = rhs->getValue().getSExtValue();
            Info.loopInfo.isConstBound = true;
            return true;
        } else if (const auto *declRef = dyn_cast<DeclRefExpr>(cond->getRHS()->IgnoreParenImpCasts())) {
            // 处理变量边界
            Info.loopInfo.isConstBound = false;
            return true;
        }
    }
    return false;
}

bool ArrayMatcher::analyzeLoopIncrement(const ForStmt *Loop, ArrayAccessInfo &Info)
{
    if (const auto *inc = dyn_cast<UnaryOperator>(Loop->getInc())) {
        Info.loopInfo.step = 1;
        return true;
    } else if (const auto *inc = dyn_cast<BinaryOperator>(Loop->getInc())) {
        if (const auto *literal = dyn_cast<IntegerLiteral>(inc->getRHS()->IgnoreParenImpCasts())) {
            Info.loopInfo.step = literal->getValue().getSExtValue();
            return true;
        }
    }
    Info.loopInfo.step = 1; // 默认步长
    return false;
}

void ArrayMatcher::collectArrayComputations(const Stmt *stmt,
                                            const std::string &arrayName,
                                            std::vector<ArrayComputeInfo> &computeInfos,
                                            SourceManager &SM,
                                            const LangOptions &langOpts,
                                            const std::string &funcName)
{
    // 使用递归遍历语法树来收集所有计算
    if (!stmt) return;

    // 检查是否是二元操作
    if (const auto *bo = dyn_cast<BinaryOperator>(stmt)) {
        bool containsArray = false;
        std::string expr = getSourceText(bo, SM, langOpts);

        // 检查左右操作数是否包含目标数组
        auto checkOperand = [&](const Expr *operand) {
            if (const auto *arrayRef = dyn_cast<ArraySubscriptExpr>(operand->IgnoreParenImpCasts())) {
                if (const auto *base = dyn_cast<DeclRefExpr>(arrayRef->getBase()->IgnoreParenImpCasts())) {
                    if (base->getNameInfo().getAsString() == arrayName) {
                        containsArray = true;
                    }
                }
            }
        };

        checkOperand(bo->getLHS());
        checkOperand(bo->getRHS());

        if (containsArray) {
            ArrayComputeInfo compInfo;
            compInfo.expression = expr;
            compInfo.location = {
                SM.getFilename(bo->getBeginLoc()).str(),
                funcName,
                SM.getSpellingLineNumber(bo->getBeginLoc()),
                SM.getSpellingLineNumber(bo->getEndLoc()),
                expr
            };

            // 确定操作类型
            if (bo->isAssignmentOp()) {
                compInfo.opType = containsArray ? ArrayOpType::WRITE : ArrayOpType::READ;
            } else {
                compInfo.opType = ArrayOpType::READ;
            }

            // 收集依赖变量
            class DependencyVisitor : public RecursiveASTVisitor<DependencyVisitor>
            {
            public:
                std::vector<std::string> dependencies;

                bool VisitDeclRefExpr(DeclRefExpr *expr)
                {
                    dependencies.push_back(expr->getNameInfo().getAsString());
                    return true;
                }
            };

            DependencyVisitor visitor;
            visitor.TraverseStmt(const_cast<Stmt *>(stmt));
            compInfo.dependentVars = std::move(visitor.dependencies);

            computeInfos.push_back(std::move(compInfo));
        }
    }

    // 递归遍历所有子节点
    for (const Stmt *child: stmt->children()) {
        collectArrayComputations(child, arrayName, computeInfos, SM, langOpts, funcName);
    }
}

bool ArrayMatcher::isValidLoop(const ForStmt *Loop) const
{
    // 验证是否是规范的for循环结构
    if (!Loop->getInit() || !Loop->getCond() || !Loop->getInc())
        return false;

    // 验证循环变量声明
    if (const auto *init = dyn_cast<DeclStmt>(Loop->getInit())) {
        if (!init->isSingleDecl() || !isa<VarDecl>(init->getSingleDecl()))
            return false;
    }

    return true;
}

// 获取源代码文本的辅助函数
std::string ArrayMatcher::getSourceText(const Stmt *stmt,
                                        SourceManager &SM,
                                        const LangOptions &langOpts)
{
    SourceLocation start = stmt->getBeginLoc();
    SourceLocation end = stmt->getEndLoc();
    return Lexer::getSourceText(
        CharSourceRange::getCharRange(start,
                                      Lexer::getLocForEndOfToken(end, 0, SM, langOpts)),
        SM, langOpts).str();
}

// 获取当前函数名的辅助函数
std::string ArrayMatcher::getCurrentFunctionName(const MatchFinder::MatchResult &Result)
{
    if (const auto *function = Result.Nodes.getNodeAs<FunctionDecl>("functionDecl")) {
        return function->getNameAsString();
    }
    return "";
}

// 收集数组计算信息
void ArrayMatcher::collectArrayComputeInfo(const ArraySubscriptExpr *Array,
                                           const ForStmt *Loop,
                                           ArrayAccessInfo &Info,
                                           const MatchFinder::MatchResult &Result)
{
    ComputeVisitor visitor(Info.arrayName,
                           *Result.SourceManager,
                           Result.Context->getLangOpts(),
                           Info.arrayLocation.functionName);
    visitor.TraverseStmt(const_cast<Stmt *>(Loop->getBody()));
    Info.computeInfos = std::move(visitor.computeInfos);
}

bool ArrayMatcher::getLoopInfo(const ForStmt *Loop, ArrayAccessInfo &Info) const
{
    // 分析循环初始值
    if (const auto *init = dyn_cast<DeclStmt>(Loop->getInit())) {
        if (const auto *varDecl = dyn_cast<VarDecl>(init->getSingleDecl())) {
            if (const auto *initExpr = varDecl->getInit()) {
                if (const auto *literal = dyn_cast<IntegerLiteral>(initExpr)) {
                    Info.loopInfo.start = literal->getValue().getSExtValue();
                }
            }
        }
    }

    // 分析循环条件
    if (const auto *cond = dyn_cast<BinaryOperator>(Loop->getCond())) {
        if (const auto *rhs = dyn_cast<IntegerLiteral>(cond->getRHS()->IgnoreParenImpCasts())) {
            Info.loopInfo.end = rhs->getValue().getSExtValue();
            Info.loopInfo.isConstBound = true;
        } else {
            Info.loopInfo.isConstBound = false;
        }
    }

    // 分析步长
    if (const auto *inc = dyn_cast<UnaryOperator>(Loop->getInc())) {
        Info.loopInfo.step = 1;
    } else if (const auto *inc = dyn_cast<BinaryOperator>(Loop->getInc())) {
        if (const auto *literal = dyn_cast<IntegerLiteral>(inc->getRHS()->IgnoreParenImpCasts())) {
            Info.loopInfo.step = literal->getValue().getSExtValue();
        }
    }

    return true;
}

ArrayMatcher::ComputeVisitor::ComputeVisitor(const std::string &arrayName,
                                             SourceManager &SM,
                                             const LangOptions &langOpts,
                                             const std::string &funcName)
    : arrayName(arrayName), SM(SM), langOpts(langOpts), funcName(funcName)
{
}

bool ArrayMatcher::ComputeVisitor::VisitBinaryOperator(BinaryOperator *op)
{
    // 检查是否包含目标数组
    if (containsArray(op, arrayName)) {
        ArrayComputeInfo compute;
        compute.expression = getSourceText(op, SM, langOpts);
        compute.opType = determineOpType(op);
        compute.location = getLocation(op);
        compute.dependentVars = collectDependencies(op);
        computeInfos.push_back(compute);
    }
    return true;
}

bool ArrayMatcher::ComputeVisitor::containsArray(const Expr *expr, const std::string &arrayName) const
{
    if (const auto *arrayExpr = dyn_cast<ArraySubscriptExpr>(expr)) {
        if (const auto *base = dyn_cast<DeclRefExpr>(
            arrayExpr->getBase()->IgnoreParenImpCasts())) {
            return base->getNameInfo().getAsString() == arrayName;
        }
    }
    return false;
}

ArrayOpType ArrayMatcher::ComputeVisitor::determineOpType(BinaryOperator *op) const
{
    if (op->isAssignmentOp()) {
        return containsArray(op->getLHS(), arrayName) ? ArrayOpType::WRITE : ArrayOpType::READ;
    }
    return ArrayOpType::READ;
}

LocationInfo ArrayMatcher::ComputeVisitor::getLocation(BinaryOperator *op) const
{
    return {
        SM.getFilename(op->getBeginLoc()).str(),
        funcName,
        SM.getSpellingLineNumber(op->getBeginLoc()),
        SM.getSpellingLineNumber(op->getEndLoc()),
        getSourceText(op, SM, langOpts)
    };
}

std::vector<std::string> ArrayMatcher::ComputeVisitor::collectDependencies(const Expr *expr) const
{
    std::vector<std::string> deps;
    collectDependenciesImpl(expr, deps);
    return deps;
}

void ArrayMatcher::ComputeVisitor::collectDependenciesImpl(const Expr *expr, std::vector<std::string> &deps) const
{
    if (!expr) return;

    if (const auto *declRef = dyn_cast<DeclRefExpr>(expr)) {
        deps.push_back(declRef->getNameInfo().getAsString());
    }

    for (const Stmt *child: expr->children()) {
        if (const Expr *childExpr = dyn_cast_or_null<Expr>(child)) {
            collectDependenciesImpl(childExpr, deps);
        }
    }
}
-------

文件的相对路径：src/preprocessor_config.cpp
文件内容：
#include "preprocessor_config.h"
#include "command_line_options.h"
#include "array_matcher.h"
#include "code_modifier.h"
#include "util.h"
#include <iostream>

void PreprocessorConfig::configure(clang::CompilerInstance &CI)
{
    clang::Preprocessor &PP = CI.getPreprocessor();
    auto& options = CommandLineOptions::instance();

    if (options.getLocateMode() || options.getRestoreMode()) {
        std::string predefs = PP.getPredefines();
        predefs += "\n"
                "#ifdef global\n"
                "#undef global\n"
                "#endif\n"
                "#define global\n"

                "#ifdef share\n"
                "#undef share\n"
                "#endif\n"
                "#define share\n"

                "#ifdef gsm\n"
                "#undef gsm\n"
                "#endif\n"
                "#define gsm\n"

                "#ifdef __attribute__\n"
                "#undef __attribute__\n"
                "#endif\n"
                "#define __attribute__(x)\n"

                "#ifdef section\n"
                "#undef section\n"
                "#endif\n"
                "#define section(x)\n";

        PP.setPredefines(predefs);
    }
}-------

文件的相对路径：src/code_modifier.cpp
文件内容：
#include "code_modifier.h"

void CodeModifier::run(const clang::ast_matchers::MatchFinder::MatchResult &Result)
{
    const auto *arrayExpr = Result.Nodes.getNodeAs<clang::ArraySubscriptExpr>("arrayAccess");
    if (!arrayExpr)
        return;

    // 获取原始代码的属性和宏
    clang::SourceManager &SM = Result.Context->getSourceManager();
    const clang::LangOptions &LangOpts = Result.Context->getLangOpts();

    // 在插入新代码时，保持原有的属性和宏定义
    clang::SourceLocation loc = arrayExpr->getBeginLoc();

    // 获取完整的源代码，包括属性
    clang::CharSourceRange range =
        clang::CharSourceRange::getCharRange(arrayExpr->getBeginLoc(), arrayExpr->getEndLoc());
    std::string originalCode = clang::Lexer::getSourceText(range, SM, LangOpts).str();

    // 修改代码时保持原有属性
    rewrite.InsertText(loc, "/* Array access modified */\n" + originalCode, true);
}

void ExtendedCodeModifier::addBoundsCheck(const clang::ArraySubscriptExpr *Array, const clang::ForStmt *Loop)
{
    clang::SourceLocation loc = Array->getBeginLoc();

    // 获取数组名和索引变量名
    std::string arrayName;
    if (const auto *baseExpr = llvm::dyn_cast<clang::DeclRefExpr>(Array->getBase()->IgnoreParenImpCasts())) {
        arrayName = baseExpr->getNameInfo().getAsString();
    }

    std::string indexName;
    if (const auto *idx = llvm::dyn_cast<clang::DeclRefExpr>(Array->getIdx()->IgnoreParenImpCasts())) {
        indexName = idx->getNameInfo().getAsString();
    }

    // 生成适当的边界检查代码
    std::string check = "/* 边界检查 */\n";
    check += "if (" + indexName + " >= sizeof(" + arrayName + ")/sizeof(" + arrayName + "[0])) {\n";
    check += "    /* 根据函数返回类型处理错误情况 */\n";
    check += "    errno = ERANGE;\n";
    check += "    return;\n";
    check += "}\n";

    rewrite.InsertText(loc, check, true);
}

void ExtendedCodeModifier::addOptimizationHint(const clang::ArraySubscriptExpr *Array)
{
    clang::SourceLocation loc = Array->getBeginLoc();
    std::string hint = "/* 考虑使用SIMD指令优化 */\n";
    rewrite.InsertText(loc, hint, true);
}

void ExtendedCodeModifier::addParallelizationHint(const clang::ForStmt *Loop)
{
    clang::SourceLocation loc = Loop->getBeginLoc();
    std::string hint = "/* 考虑使用OpenMP并行化 */\n";
    rewrite.InsertText(loc, hint, true);
}-------

文件的相对路径：src/json_manager.cpp
文件内容：
#include "json_manager.h"

JsonManager &JsonManager::instance()
{
    static JsonManager instance;
    return instance;
}

void JsonManager::readInputJson(const std::string &filename)
{
    if (filename.empty()) {
        throw std::runtime_error("No input JSON file specified");
    }

    std::ifstream input(filename);
    if (!input.is_open()) {
        throw std::runtime_error("Failed to open input JSON file: " + filename);
    }

    try {
        input >> inputJson;
        validateInputJson();
    } catch (const json::exception &e) {
        throw std::runtime_error("JSON parsing error: " + std::string(e.what()));
    }
}

// src/json_manager.cpp
void JsonManager::writeOutputJson(const std::string &filename)
{
    if (filename.empty()) {
        throw std::runtime_error("No output file specified");
    }

    // 确保输出目录存在
    std::size_t found = filename.find_last_of("/\\");
    if (found != std::string::npos) {
        std::string dir = filename.substr(0, found);
        std::system(("mkdir -p " + dir).c_str());
    }

    std::ofstream out(filename);
    if (!out.is_open()) {
        throw std::runtime_error("Failed to open output file: " + filename);
    }

    // 如果 JSON 为空，至少输出一个空数组
    if (outputJson.empty()) {
        outputJson = json::array();
    }

    // 使用4空格缩进美化输出
    out << outputJson.dump(4) << std::endl;

    // 确保文件被正确写入
    out.flush();
    if (!out.good()) {
        throw std::runtime_error("Error occurred while writing to file: " + filename);
    }

    out.close();
    llvm::outs() << "Successfully wrote JSON output to: " << filename << "\n";
}

json &JsonManager::getInputJson()
{
    return inputJson;
}

json &JsonManager::getOutputJson()
{
    return outputJson;
}

void JsonManager::clearOutputJson()
{
    outputJson = json::array();
}

void JsonManager::addArrayAccess(const ArrayAccessInfo &info)
{
    const auto &options = CommandLineOptions::instance();
    if (options.getLocateMode()) {
        handleLocateMode(info);
    } else if (options.getRestoreMode()) {
        handleRestoreMode(info);
    } else {
        handleModifyMode(info);
    }
}

void JsonManager::handleLocateMode(const ArrayAccessInfo &info)
{
    // Create array info object
    json arrayInfo = json::object({
        {"name", info.arrayName},
        {"indexVar", info.indexVarName},
        {"line", info.arrayLocation.startLine},
        {"sourceText", info.arrayLocation.sourceText}
    });

    // Find or create file entry
    bool fileFound = false;
    for (auto &fileEntry: outputJson) {
        if (fileEntry["filename"] == info.arrayLocation.filename) {
            fileFound = true;

            // Find or create function entry
            bool functionFound = false;
            for (auto &funcEntry: fileEntry["functions"]) {
                if (funcEntry["name"] == info.arrayLocation.functionName) {
                    functionFound = true;

                    // Find or create loop entry
                    bool loopFound = false;
                    for (auto &loopEntry: funcEntry["forLoops"]) {
                        if (loopEntry["startLine"] == info.forLoopLocation.startLine) {
                            loopFound = true;

                            // Add array access if not exists
                            bool arrayExists = false;
                            for (const auto &arr: loopEntry["arrays"]) {
                                if (arr["name"] == info.arrayName &&
                                    arr["line"] == info.arrayLocation.startLine) {
                                    arrayExists = true;
                                    break;
                                }
                            }

                            if (!arrayExists) {
                                loopEntry["arrays"].push_back(arrayInfo);
                            }
                            break;
                        }
                    }

                    if (!loopFound) {
                        // Create new loop entry
                        json loopEntry = json::object({
                            {"startLine", info.forLoopLocation.startLine},
                            {"endLine", info.forLoopLocation.endLine},
                            {"sourceText", info.forLoopLocation.sourceText},
                            {"arrays", json::array({arrayInfo})}
                        });
                        funcEntry["forLoops"].push_back(loopEntry);
                    }
                    break;
                }
            }

            if (!functionFound) {
                // Create new function entry
                json funcEntry = json::object({
                    {"name", info.arrayLocation.functionName},
                    {
                        "forLoops", json::array({
                            json::object({
                                {"startLine", info.forLoopLocation.startLine},
                                {"endLine", info.forLoopLocation.endLine},
                                {"sourceText", info.forLoopLocation.sourceText},
                                {"arrays", json::array({arrayInfo})}
                            })
                        })
                    }
                });
                fileEntry["functions"].push_back(funcEntry);
            }
            break;
        }
    }

    if (!fileFound) {
        // Create new file entry
        json fileEntry = json::object({
            {"filename", info.arrayLocation.filename},
            {
                "functions", json::array({
                    json::object({
                        {"name", info.arrayLocation.functionName},
                        {
                            "forLoops", json::array({
                                json::object({
                                    {"startLine", info.forLoopLocation.startLine},
                                    {"endLine", info.forLoopLocation.endLine},
                                    {"sourceText", info.forLoopLocation.sourceText},
                                    {"arrays", json::array({arrayInfo})}
                                })
                            })
                        }
                    })
                })
            }
        });
        outputJson.push_back(fileEntry);
    }
}

void JsonManager::handleRestoreMode(const ArrayAccessInfo &info)
{
    json computeEntry = {
        {"arrayName", info.arrayName},
        {"functionName", info.arrayLocation.functionName},
        {"indexVariable", info.indexVarName},
        {
            "location", {
                {"filename", info.arrayLocation.filename},
                {"startLine", info.arrayLocation.startLine},
                {"endLine", info.arrayLocation.endLine},
                {"sourceText", info.arrayLocation.sourceText}
            }
        },
        {
            "loop", {
                {"startLine", info.forLoopLocation.startLine},
                {"endLine", info.forLoopLocation.endLine},
                {"sourceText", info.forLoopLocation.sourceText},
                {
                    "bounds", {
                        {"start", info.loopInfo.start},
                        {"end", info.loopInfo.end},
                        {"step", info.loopInfo.step},
                        {"isConstBound", info.loopInfo.isConstBound}
                    }
                }
            }
        },
        {"computations", json::array()}
    };

    // 添加所有数组计算信息
    for (const auto &compute: info.computeInfos) {
        json compInfo = {
            {
                "type", [&compute]() {
                    switch (compute.opType) {
                        case ArrayOpType::READ: return "read";
                        case ArrayOpType::WRITE: return "write";
                        case ArrayOpType::READ_WRITE: return "read_write";
                        default: return "unknown";
                    }
                }()
            },
            {"expression", compute.expression},
            {
                "location", {
                    {"startLine", compute.location.startLine},
                    {"endLine", compute.location.endLine},
                    {"sourceText", compute.location.sourceText}
                }
            },
            {"dependencies", compute.dependentVars}
        };
        computeEntry["computations"].push_back(compInfo);
    }

    // 更新输出JSON结构
    bool fileExists = false;
    for (auto &file: outputJson) {
        if (file["filename"] == info.arrayLocation.filename) {
            fileExists = true;
            if (!file.contains("arrayAccesses")) {
                file["arrayAccesses"] = json::array();
            }
            file["arrayAccesses"].push_back(computeEntry);
            break;
        }
    }

    if (!fileExists) {
        outputJson.push_back({
            {"filename", info.arrayLocation.filename},
            {"arrayAccesses", json::array({computeEntry})}
        });
    }
}

void JsonManager::validateInputJson() const
{
    if (!inputJson.is_array()) {
        throw std::runtime_error("Input JSON must be an array");
    }

    for (const auto &item: inputJson) {
        if (!item.contains("functions")) {
            throw std::runtime_error("Input JSON item missing required 'functions' field");
        }

        if (!item["functions"].is_array()) {
            throw std::runtime_error("'functions' field must be an array");
        }

        for (const auto &func: item["functions"]) {
            if (!func.contains("name")) {
                throw std::runtime_error("Function object missing required 'name' field");
            }

            if (!func["name"].is_string()) {
                throw std::runtime_error("Function 'name' must be a string");
            }
        }
    }
}
-------

文件的相对路径：src/command_line_options.cpp
文件内容：
#include "command_line_options.h"
#include <filesystem>

// Static member initialization
llvm::cl::OptionCategory CommandLineOptions::ToolCategory("Array Analysis Tool Options");

llvm::cl::opt<bool> CommandLineOptions::LocateMode("locate",
    llvm::cl::desc("Enable locate mode"),
    llvm::cl::cat(ToolCategory));

llvm::cl::opt<bool> CommandLineOptions::RestoreMode("restore",
    llvm::cl::desc("Enable restore mode"),
    llvm::cl::cat(ToolCategory));

llvm::cl::opt<bool> CommandLineOptions::ModifyMode("modify",
    llvm::cl::desc("Enable modify mode"),
    llvm::cl::cat(ToolCategory));

// 新增：诊断日志选项
llvm::cl::opt<bool> CommandLineOptions::DiagnosticLogToFile("log-to-file",
    llvm::cl::desc("Write diagnostic messages to file instead of terminal"),
    llvm::cl::cat(ToolCategory));

llvm::cl::opt<std::string> CommandLineOptions::DiagnosticLogFile("log-file",
    llvm::cl::desc("Specify diagnostic log file path (default: test/tool_diagnostics.log)"),
    llvm::cl::init("test/tool_diagnostics.log"),
    llvm::cl::value_desc("filename"),
    llvm::cl::cat(ToolCategory));

llvm::cl::opt<std::string> CommandLineOptions::InputFile("input",
    llvm::cl::desc("Specify input JSON file"),
    llvm::cl::value_desc("filename"),
    llvm::cl::cat(ToolCategory));

llvm::cl::opt<std::string> CommandLineOptions::OutputFile("output",
    llvm::cl::desc("Specify output file"),
    llvm::cl::value_desc("filename"),
    llvm::cl::cat(ToolCategory));

CommandLineOptions& CommandLineOptions::instance() {
    static CommandLineOptions instance;
    return instance;
}

void CommandLineOptions::initialize(int argc, const char** argv) {
    auto ExpectedParser = clang::tooling::CommonOptionsParser::create(argc, argv, ToolCategory);
    if (!ExpectedParser) {
        llvm::errs() << ExpectedParser.takeError();
        throw std::runtime_error("Failed to parse command line options");
    }
    OptionsParser = std::make_unique<clang::tooling::CommonOptionsParser>(std::move(ExpectedParser.get()));

    // 如果指定了输出到文件，确保日志文件目录存在
    if (DiagnosticLogToFile) {
        std::filesystem::path logPath(DiagnosticLogFile.getValue());  // 修复：使用 getValue() 获取字符串值
        std::filesystem::create_directories(logPath.parent_path());
    }
}

bool CommandLineOptions::getLocateMode() const {
    return LocateMode;
}

bool CommandLineOptions::getRestoreMode() const {
    return RestoreMode;
}

bool CommandLineOptions::getModifyMode() const {
    return ModifyMode;
}

bool CommandLineOptions::getDiagnosticLogToFile() const {
    return DiagnosticLogToFile;
}

std::string CommandLineOptions::getDiagnosticLogFile() const {
    return DiagnosticLogFile;  // llvm::cl::opt<std::string> 会自动转换为 std::string
}

std::string CommandLineOptions::getInputFile() const {
    return InputFile;
}

std::string CommandLineOptions::getOutputFile() const {
    return OutputFile;
}

clang::tooling::CommonOptionsParser& CommandLineOptions::getOptionsParser() {
    if (!OptionsParser) {
        throw std::runtime_error("OptionsParser not initialized");
    }
    return *OptionsParser;
}

const clang::tooling::CommonOptionsParser& CommandLineOptions::getOptionsParser() const {
    if (!OptionsParser) {
        throw std::runtime_error("OptionsParser not initialized");
    }
    return *OptionsParser;
}

[[nodiscard]] std::string CommandLineOptions::toString() const {
    std::string runMode;
    if (getLocateMode()) runMode += "Locate Mode";
    if (getRestoreMode()) runMode += (runMode.empty() ? "" : ", ") + std::string("Restore Mode");
    if (getModifyMode()) runMode += (runMode.empty() ? "" : ", ") + std::string("Modify Mode");
    if (runMode.empty()) runMode = "No Mode Selected";

    return std::string("\nCommand Line Options:\n") +
           std::string(20, '=') + "\n" +
           "Run Mode: " + runMode + "\n" +
           "InputFile: '" + getInputFile() + "'\n" +
           "OutputFile: '" + getOutputFile() + "'\n" +
           "Diagnostic Output: " + (getDiagnosticLogToFile() ?
               "File ('" + getDiagnosticLogFile() + "')" : "Terminal") + "\n" +
           std::string(20, '=') + "\n\n";
}-------

文件的相对路径：src/diagnostic_tool.cpp
文件内容：
#include "diagnostic_tool.h"

#include <iomanip>
#include <sstream>
#include <clang/Basic/SourceManager.h>
#include <clang/Basic/DiagnosticCategories.h>
#include <llvm/ADT/SmallString.h>
#include <llvm/Support/FileSystem.h>
#include <llvm/Support/Format.h>

MyDiagnosticConsumer::MyDiagnosticConsumer(bool logToFile,
                                           const std::string &logFilename)
    : LogToFile(logToFile),
      LogFilename(logFilename),
      ErrorCount(0),
      WarningCount(0)
{
    DiagOpts = std::make_shared<clang::DiagnosticOptions>();
    DiagOpts->ShowColors = !LogToFile; // 只在终端输出时启用颜色
    DiagOpts->ShowCarets = true;
    DiagOpts->ShowFixits = true;
    DiagOpts->TabStop = 4;
    DiagOpts->MessageLength = 120;

    if (LogToFile) {
        std::error_code EC;
        llvm::raw_fd_ostream OS(LogFilename, EC, llvm::sys::fs::OF_None);
        if (EC) {
            llvm::errs() << "Error opening log file: " << EC.message() << "\n";
        } else {
            auto now = std::chrono::system_clock::now();
            auto in_time_t = std::chrono::system_clock::to_time_t(now);
            std::stringstream ss;
            ss << "=== Diagnostic Log ===\n"
                    << "Time: " << std::put_time(std::localtime(&in_time_t), "%Y-%m-%d, %H:%M:%S") << "\n"
                    << "==================\n\n";

            OS << ss.str();
        }
    }
}

const char *MyDiagnosticConsumer::GetSeverityColor(clang::DiagnosticsEngine::Level Level) const
{
    if (LogToFile) return ""; // 日志文件中不使用颜色

    switch (Level) {
        case clang::DiagnosticsEngine::Fatal:
        case clang::DiagnosticsEngine::Error:
            return Colors::RED;
        case clang::DiagnosticsEngine::Warning:
            return Colors::YELLOW;
        case clang::DiagnosticsEngine::Note:
            return Colors::CYAN;
        case clang::DiagnosticsEngine::Remark:
            return Colors::GREEN;
        default:
            return Colors::RESET;
    }
}

std::string MyDiagnosticConsumer::Color(const char *ColorCode) const
{
    return LogToFile ? "" : ColorCode; // 日志文件中不使用颜色
}

void MyDiagnosticConsumer::HandleDiagnostic(clang::DiagnosticsEngine::Level DiagLevel,
                                            const clang::Diagnostic &Info)
{
    DiagnosticInfo diagInfo;
    diagInfo.Level = DiagLevel;

    // 获取位置信息
    if (Info.getLocation().isValid()) {
        clang::FullSourceLoc FullLoc(Info.getLocation(), Info.getSourceManager());
        diagInfo.Filename = FullLoc.getManager().getFilename(FullLoc).str();
        diagInfo.Line = FullLoc.getSpellingLineNumber();
        diagInfo.Column = FullLoc.getSpellingColumnNumber();

        // 获取代码片段和错误位置标记
        std::tie(diagInfo.CodeSnippet, diagInfo.CaretLine) =
                GetSourceSnippetAndCaret(FullLoc, Info, 2);
    }

    // 获取错误信息
    llvm::SmallVector<char, 100> MessageStr;
    Info.FormatDiagnostic(MessageStr);
    diagInfo.Message = std::string(MessageStr.begin(), MessageStr.end());

    // 设置严重程度并更新计数器
    switch (DiagLevel) {
        case clang::DiagnosticsEngine::Fatal:
            diagInfo.Severity = "Fatal Error";
            ErrorCount++;
            break;
        case clang::DiagnosticsEngine::Error:
            diagInfo.Severity = "Error";
            ErrorCount++;
            break;
        case clang::DiagnosticsEngine::Warning:
            diagInfo.Severity = "Warning";
            WarningCount++;
            break;
        case clang::DiagnosticsEngine::Note:
            diagInfo.Severity = "Note";
            break;
        case clang::DiagnosticsEngine::Remark:
            diagInfo.Severity = "Remark";
            break;
        default:
            diagInfo.Severity = "Other";
    }

    // 获取诊断类别
    unsigned DiagID = Info.getID();
    llvm::StringRef Category = clang::DiagnosticIDs::getCategoryNameFromID(DiagID);
    if (!Category.empty()) {
        diagInfo.Category = Category.str();
    }

    // 将诊断信息存入向量
    Diagnostics.push_back(diagInfo);
}

void MyDiagnosticConsumer::Finish()
{
    // 先输出统计信息
    PrintStatistics();

    // 然后输出所有诊断信息
    for (const auto &diagInfo: Diagnostics) {
        std::string Output = FormatDiagnostic(diagInfo);

        if (LogToFile) {
            std::error_code EC;
            llvm::raw_fd_ostream OS(LogFilename, EC,
                                    llvm::sys::fs::OpenFlags::OF_Append);
            if (!EC) {
                OS << Output;
            }
        } else {
            llvm::errs() << Output;
        }
    }

    // 清空诊断信息
    Clear();
}

std::string MyDiagnosticConsumer::GetLineContent(const clang::SourceManager &SM,
                                                 clang::SourceLocation Loc) const
{
    if (!Loc.isValid())
        return "";

    unsigned FileOffset = SM.getFileOffset(Loc);
    const char *BufferStart = SM.getCharacterData(Loc);
    if (!BufferStart)
        return "";

    const char *LineStart = BufferStart;
    llvm::Expected<llvm::StringRef> Content = SM.getBufferData(SM.getFileID(Loc));
    if (!Content) {
        return "";
    }
    llvm::StringRef BufferStr = *Content;
    while (LineStart > BufferStr.begin() && LineStart[-1] != '\n')
        --LineStart;

    const char *LineEnd = BufferStart;
    while (*LineEnd && *LineEnd != '\n')
        ++LineEnd;

    return std::string(LineStart, LineEnd);
}

std::pair<std::string, std::string> MyDiagnosticConsumer::GetSourceSnippetAndCaret(
    const clang::FullSourceLoc &Loc,
    const clang::Diagnostic &Info,
    unsigned Context)
{
    if (!Loc.isValid())
        return {"", ""};

    const clang::SourceManager &SM = Loc.getManager();
    unsigned LineNo = Loc.getSpellingLineNumber();
    unsigned ColNo = Loc.getSpellingColumnNumber();
    clang::FileID FID = SM.getFileID(Loc);

    std::string Snippet;
    std::string CaretLine;

    if (FID.isValid()) {
        for (unsigned i = (LineNo > Context ? LineNo - Context : 1);
             i <= LineNo + Context; ++i) {
            clang::SourceLocation StartOfLine = SM.translateLineCol(FID, i, 1);
            if (StartOfLine.isValid()) {
                bool IsErrorLine = (i == LineNo);
                std::string LineContent = GetLineContent(SM, StartOfLine);

                // 添加行号和内容
                std::string LinePrefix = std::to_string(i) + " | ";
                Snippet += LinePrefix + LineContent + "\n";

                // 为错误行生成插入符号行
                if (IsErrorLine) {
                    std::string Spaces(LinePrefix.length() - 2, ' ');
                    CaretLine = Spaces + "| " + std::string(ColNo - 1, ' ') + "^";

                    clang::SourceLocation EndLoc = Info.getLocation();
                    if (EndLoc.isValid()) {
                        unsigned EndCol = SM.getSpellingColumnNumber(EndLoc);
                        if (EndCol > ColNo) {
                            CaretLine += std::string(EndCol - ColNo - 1, '~');
                        }
                    }
                    CaretLine += "\n";
                }
            }
        }
    }
    return {Snippet, CaretLine};
}

// void MyDiagnosticConsumer::OutputDiagnostic(const DiagnosticInfo &Info)
// {
//     std::string Output = FormatDiagnostic(Info);
//
//     if (LogToFile) {
//         std::error_code EC;
//         llvm::raw_fd_ostream OS(LogFilename, EC,
//                                 llvm::sys::fs::OpenFlags::OF_Append);
//         if (!EC) {
//             OS << Output;
//         }
//     } else {
//         llvm::errs() << Output;
//     }
// }

std::string MyDiagnosticConsumer::FormatDiagnostic(const DiagnosticInfo &Info) const
{
    std::string Output;
    llvm::raw_string_ostream OS(Output);

    // 使用条件颜色输出
    const std::string separator(80, '-');
    OS << "\n" << (LogToFile ? separator : Color(Colors::DIM) + separator + Color(Colors::RESET)) << "\n";

    // 严重程度
    if (LogToFile) {
        OS << Info.Severity;
    } else {
        OS << Color(GetSeverityColor(Info.Level)) << Color(Colors::BOLD)
                << Info.Severity << Color(Colors::RESET);
    }

    // 类别
    if (!Info.Category.empty()) {
        if (LogToFile) {
            OS << " [" << Info.Category << "]";
        } else {
            OS << Color(Colors::CYAN) << " [" << Info.Category << "]" << Color(Colors::RESET);
        }
    }
    OS << "\n\n";

    // 文件位置
    if (!Info.Filename.empty()) {
        if (LogToFile) {
            OS << "In file: " << Info.Filename << ":" << Info.Line << ":" << Info.Column << "\n\n";
        } else {
            OS << Color(Colors::BLUE) << "In file: " << Info.Filename << ":"
                    << Info.Line << ":" << Info.Column << Color(Colors::RESET) << "\n\n";
        }
    }

    // 错误消息
    if (LogToFile) {
        OS << "Message: " << Info.Message << "\n\n";
    } else {
        OS << "Message: " << Color(GetSeverityColor(Info.Level))
                << Info.Message << Color(Colors::RESET) << "\n\n";
    }

    // 代码片段
    if (!Info.CodeSnippet.empty()) {
        OS << (LogToFile ? "" : Color(Colors::BOLD))
                << "Relevant Code:\n"
                << (LogToFile ? "" : Color(Colors::RESET));

        std::istringstream iss(Info.CodeSnippet);
        std::string line;
        while (std::getline(iss, line)) {
            size_t separatorPos = line.find('|');
            if (separatorPos != std::string::npos && !LogToFile) {
                // 在终端输出时，行号使用暗色
                OS << Color(Colors::DIM) << line.substr(0, separatorPos + 1)
                        << Color(Colors::RESET) << line.substr(separatorPos + 1) << "\n";
            } else {
                OS << line << "\n";
            }
        }

        if (!Info.CaretLine.empty()) {
            if (LogToFile) {
                OS << Info.CaretLine;
            } else {
                OS << Color(GetSeverityColor(Info.Level)) << Info.CaretLine
                        << Color(Colors::RESET);
            }
        }
        OS << "\n";
    }

    // 注释信息
    if (!Info.Notes.empty()) {
        OS << (LogToFile ? "" : Color(Colors::BOLD)) << "Additional Notes:\n"
                << (LogToFile ? "" : Color(Colors::RESET));
        for (const auto &Note: Info.Notes) {
            if (LogToFile) {
                OS << "  • " << Note << "\n";
            } else {
                OS << Color(Colors::CYAN) << "  • " << Note << Color(Colors::RESET) << "\n";
            }
        }
        OS << "\n";
    }

    OS << (LogToFile ? separator : Color(Colors::DIM) + separator + Color(Colors::RESET)) << "\n";
    return OS.str();
}

void MyDiagnosticConsumer::Clear()
{
    Diagnostics.clear();
    ErrorCount = 0;
    WarningCount = 0;
}

const std::vector<MyDiagnosticConsumer::DiagnosticInfo> &
MyDiagnosticConsumer::GetDiagnostics() const
{
    return Diagnostics;
}

void MyDiagnosticConsumer::PrintStatistics()
{
    std::string stats;
    if (LogToFile) {
        stats = "\nDiagnostic Statistics:\n" +
                std::string(20, '=') + "\n" +
                "Total Errors  : " + std::to_string(ErrorCount) + "\n" +
                "Total Warnings: " + std::to_string(WarningCount) + "\n" +
                std::string(20, '=') + "\n";
    } else {
        stats = Color(Colors::CYAN) + "\nDiagnostic Statistics:\n" +
                std::string(20, '=') + Color(Colors::RESET) + "\n" +
                Color(Colors::RED) + "Total Errors  : " + std::to_string(ErrorCount) +
                Color(Colors::RESET) + "\n" +
                Color(Colors::YELLOW) + "Total Warnings: " + std::to_string(WarningCount) +
                Color(Colors::RESET) + "\n" +
                Color(Colors::CYAN) + std::string(20, '=') + Color(Colors::RESET) + "\n";
    }

    if (LogToFile) {
        std::error_code EC;
        llvm::raw_fd_ostream OS(LogFilename, EC,
                                llvm::sys::fs::OpenFlags::OF_Append);
        if (!EC) {
            OS << stats;
        }
    }
    llvm::errs() << stats;
}

// void MyDiagnosticConsumer::OutputAllDiagnostics() const
// {
//     for (const auto &diagInfo: Diagnostics) {
//         std::string Output = FormatDiagnostic(diagInfo);
//
//         if (LogToFile) {
//             std::error_code EC;
//             llvm::raw_fd_ostream OS(LogFilename, EC,
//                                     llvm::sys::fs::OpenFlags::OF_Append);
//             if (!EC) {
//                 OS << Output;
//             }
//         } else {
//             llvm::errs() << Output;
//         }
//     }
// }
-------

文件的相对路径：src/main.cpp
文件内容：
#include "diagnostic_tool.h"
#include "code_modifier.h"
#include "frontend_action.h"
#include "command_line_options.h"
#include "json_manager.h"
#include "clang/Rewrite/Core/Rewriter.h"
#include <iostream>
#include <memory>
#include <clang/Frontend/CompilerInstance.h>

using namespace clang::tooling;

// Global rewriter for modify mode
clang::Rewriter TheRewriter;


int main(int argc, const char **argv)
{
    try {
        // 初始化命令行选项
        CommandLineOptions::instance().initialize(argc, argv);
        auto &options = CommandLineOptions::instance();
        llvm::outs() << options.toString();
        // 获取对CommonOptionsParser的非常量引用
        auto &optionsParser = options.getOptionsParser();

        // 创建编译数据库和源文件路径
        auto &compilations = optionsParser.getCompilations();
        auto sourcePaths = optionsParser.getSourcePathList();

        // 创建ClangTool
        ClangTool Tool(compilations, sourcePaths);

        auto &jsonManager = JsonManager::instance();

        // 创建诊断消费者
        auto DiagConsumer = std::make_shared<MyDiagnosticConsumer>(
            CommandLineOptions::instance().getDiagnosticLogToFile(),
            CommandLineOptions::instance().getDiagnosticLogFile()
        );




        if (options.getLocateMode()) {
            // 使用自定义前端操作运行工具
            if (Tool.run(createCustomFrontendActionFactory(DiagConsumer).get()) != 0) {
                llvm::errs() << "Error: Some errors happened in the locate mode.\n";
                return 1;
            }

            // 如果指定，则写入输出
            if (!options.getOutputFile().empty()) {
                jsonManager.writeOutputJson(options.getOutputFile());
            }
        } else if (options.getRestoreMode()) {
            if (options.getInputFile().empty()) {
                llvm::errs() << "Error: No input JSON file specified\n";
                return 1;
            }

            // 读取输入JSON
            jsonManager.readInputJson(options.getInputFile());

            // 运行工具
            Tool.run(createCustomFrontendActionFactory(DiagConsumer).get());

            // 如果指定，则写入输出
            if (!options.getOutputFile().empty()) {
                jsonManager.writeOutputJson(options.getOutputFile());
            }
        } else if (options.getModifyMode()) {
            if (options.getInputFile().empty()) {
                llvm::errs() << "Error: Modify mode requires input JSON file\n";
                return 1;
            }

            // 读取输入JSON
            jsonManager.readInputJson(options.getInputFile());

            // 运行工具
            if (Tool.run(createCustomFrontendActionFactory(DiagConsumer).get()) != 0) {
                llvm::errs() << "Error: Some errors happened in the modify mode.\n";
                return 1;
            }

            // 写入修改后的代码
            if (!options.getOutputFile().empty()) {
                std::error_code EC;
                llvm::raw_fd_ostream OS(options.getOutputFile(), EC);
                if (EC) {
                    llvm::errs() << "Error opening output file: " << EC.message() << "\n";
                    return 1;
                }

                const RewriteBuffer *RewriteBuf =
                        TheRewriter.getRewriteBufferFor(TheRewriter.getSourceMgr().getMainFileID());
                if (!RewriteBuf) {
                    llvm::errs() << "No modifications made to source file.\n";
                    return 1;
                }

                // 保留头文件和特殊属性
                OS << "#include <compiler/m3000.h>\n";
                OS << "#include \"hthread_device.h\"\n\n";
                OS << std::string(RewriteBuf->begin(), RewriteBuf->end());
            }
        } else {
            llvm::errs() << "Error: Please specify run mode (-locate, -restore, or -modify)\n";
            return 1;
        }
        // 在所有处理完成后，输出诊断信息
        DiagConsumer->Finish();

        return 0;
    } catch (const std::exception &e) {
        llvm::errs() << "Error: " << e.what() << "\n";
        return 1;
    }
}
-------

